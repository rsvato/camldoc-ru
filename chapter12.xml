<?xml version="1.0" encoding="windows-1251"?>
<!-- <!DOCTYPE chapter SYSTEM "core.dtd"> -->
<chapter name="Генераторы синаксических и лексических анализаторов (ocamllex, ocamlyacc)" number="12">
  <abstract>
    <para>В этой главе описываются два генератора -
      <command>ocamllex</command>, создающий лексический анализатор из
      набора регулярных выражений со связанными с ними семантическими
      действиями, и <command>ocamlyacc</command>, создающий
      синтаксический анализатор из грамматики и связанных с ней
      семантических действий.</para>
    <para>Эти программы весьма близки к известным командам
      <command>lex</command> и <command>yacc</command>, доступным в
      большинстве сред С. Дальнейшее изложение подразумевает знание
      <command>lex</command> и <command>yacc</command>, поскольку
      описывает синтаксис и отличия от них <command>ocamllex</command>
      и <command>ocamlyacc</command>, но не рассказывает о том, как
      готовить описания лексических и синтаксических анализаторов
      <command>lex</command> и <command>yacc</command>. Читатели, не
      знакомые с этими инструментами, могут обратиться к книгам
      "Compilers: princioles, techniques and tools" Aho, Sethi и
      Ullman (Addison-Wesley, 1986) и "Lex &amp; Yacc" Levine, Mason и
      Brown (O'Reilly, 1992).</para>
  </abstract>
  <main-matters>
    <section name="Обзор ocamllex">
      <para><command>ocamllex</command> создает лексический анализатор
	из набора регулярных выражений и связанных с ними
	семантических действий в стиле <command>lex</command>. Если
	входной файл называется <command>lexer.mll</command>,
	команда</para>
      <listing>ocamllex lexer.mll</listing>
      <para>сгенерирует файл <command>lexer.ml</command> c кодом Caml
	для лексического анализатора. В этом файле на каждое вхождение
	в определении лексического анализатора создается одна функция с
	тем же именем, что и вхождение. Аргументом для таких функций
	служит буфер анализатора, а возвращают они семантический
	атирибут, соотвествующий вхождению.</para>
      <para>Буферы анализатора - это абстрактный тип данных,
	реализованный в модуле стандартной библиотеки
	<command>Lexing</command>. Функции
	<keyword>Lexing.from_channel</keyword>,
	<keyword>Lexing.from_string</keyword> и
	<keyword>Lexing.from_function</keyword> создают лексические
	буферы, принимающие данный из канала ввода, строки символов
	или функции чтения, соотвественно (см. описание модуля
	Lexing).</para>
      <para>При использовании с синтаксичесим анализатором,
	сгенерированным <command>ocamlyacc</command> семантические
	действия вычисляют значение типа <keyword>token</keyword>,
	определенное этим анализатором (см. описание
	<command>ocamlyacc</command> ниже).</para>
    </section>
    <section name="Синтаксис определения лексического анализатора">
      <para>Формат определения лексического анализатора таков:</para>
      <listing><![CDATA[
{ заголовок }
let ident = regexp ...
rule entrypoint =
  parse regexp { action }
      | ...
      | regexp { action }
and entrypoint =
  parse ...
and ...
{ концевик }
]]></listing>
      <para>Комментарии ограничиваются <keyword>(*</keyword> и
	<keyword>*)</keyword> как обычно в Caml.</para>
      <subsection name="Заголовок и концевик" neednumber="1">
	<para>
	  <emph>Заголовок</emph> и <emph>концевик</emph> - это
	  произвольный текст Caml и фигурных скобках. Оба раздела
	  необязательны. Если они заданы, текст заголовка копируется в
	  начало генерируемого файла, а текст концевика - в конец.
	  Обычно заголовок содержит директивы <command>open</command>,
	  необходимые для действий, и при необходимости вспомогательные
	  функии.</para>
      </subsection>
      <subsection name="Именованные регулярные выражения" neednumber="1">
	<para>Между заголовком и вхождениями можно определить по именам
	  часто используемые регулярные выражения. Они записываются в
	  форме <value>let</value> <term>ident</term> <value>=</value>
	  <term>regexp</term>. В этом случае идентификатор
	  <emph>ident</emph> в дальнейшем будет использоваться как
	  сокращение для <emph>regexp</emph>.</para>
      </subsection>
      <subsection name="Вхождения" neednumber="1">
	<para>Имена вхождений должны быть допустимыми идентификаторами
	  для значений Caml (начинающимися с буквы в строчном
	  регистре). Каждое вхождение сановится функцией Caml,
	  принимающей один аргумент типа
	  <keyword>Lexing.lexbuf</keyword> - из него читаются и
	  сравниваются с регулярным выражением, соответсвующим
	  правилу, символы, пока префикс не совпадет с одним из
	  правил. Затем вычисляется соответствующее действие, которое
	  и будет значением, возвращаемым функией.</para>
	<para>Если префикс ввода совпадет с несколькими регулярными
	  выражениями, результат опредялется правилось "длиннейшего
	  совпаления" - выбирается регулярное выражение,
	  удовлетворяющее максимальному количеству символов. При
	  связке выбирается ранее совпавшее регулярное
	  выражение.</para>
      </subsection>
      <subsection name="Регулярные выражения" neednumber="1">
	<para>Регулярные выражения записываются в стиле
	  <command>lex</command> с добавками Caml-подобного
	  синтаксиса.</para>
	<dict>
	  <dict-term><value>'</value><term>char</term><value>'</value></dict-term>
	  <dict-art>
	    <para>Символьная константа с тем же синтаксисом, что и
	      соответствующий класс Objective Caml. Совпадает с
	      указанным символом.</para>
	  </dict-art>
	  <dict-term><value>_</value></dict-term>
	  <dict-art>
	    <para>(Подчеркивание.) Совпадает с любым символом.</para>
	  </dict-art>
	  <dict-term>eof</dict-term>
	  <dict-art>
	    <para>Совпадает с концом ввода лексического
	      анализатора.</para>
	    <para>На некоторых системах с интерактивным вводом, за
	      концом файла могут следовать дополнительные символы.
	      <command>ocamllex</command> не сможет правильно
	      обработать регулярное выражение для такой
	      ситуации.</para>
	  </dict-art>
	  <dict-term><value>"</value><term>string</term><value>"</value></dict-term>
	  <dict-art>
	    <para>Строковая константа с тем же синтаксисом, что и
	      соответствующий класс Objective Caml. Совпадает с
	      указанной последовательностью символов.</para>
	  </dict-art>
	  <dict-term><value>[</value><term>character-set</term><value>]</value></dict-term>
	  <dict-art>
	    <para>Совпадает с любым единичным символом из набора.
	      Допустимые наборы таковы: единичные символьные константы
	      <value>'</value><term>c</term><value>'</value>,
	      диапазоны символов
	      <value>'</value><term>c</term><sub>1</sub><value>'</value> 
	      <value>-</value>
	      <value>'</value><term>c</term><sub>2</sub><value>'</value> 
	      (все символы от <emph>c</emph><sub>1</sub> до
	      <emph>c</emph><sub>2</sub> включительно) или объединение
	      двух и больше наборов.</para>
	  </dict-art>
	  <dict-term>
	    <value>[^</value><term>character-set</term><value>]</value>
	  </dict-term>
	  <dict-art>
	    <para>Любой символ, не входящий в данный набор.</para>
	  </dict-art>
	  <dict-term><term>regexp</term><value>*</value></dict-term>
	  <dict-art>
	    <para>(Повторение.) Ноль и более совпадающих строк.</para>
	  </dict-art>
	  <dict-term><term>regexp</term><value>+</value></dict-term>
	  <dict-art>
	    <para>(Строгое повторение.) Одна и более совпадающая
	      строка.</para>
	  </dict-art>
	  <dict-term><term>regexp</term><value>?</value></dict-term>
	  <dict-art>
	    <para>(Вариант.) Пустая стока или строка, совпадающая с
	      <term>regexp</term></para>
	  </dict-art>
	  <dict-term><term>regexp</term><sub>1</sub><value>|</value><term>regexp</term><sub>2</sub></dict-term>
	  <dict-art>
	    <para>(Альтернатива.) Любая строка, совпадающая либо с
	      <term>regexp</term><sub>1</sub>, либо с
	      <term>regexp</term><sub>2</sub>.</para>
	  </dict-art>
	  <dict-term><term>regexp</term><sub>1</sub>
	    <term>regexp</term><sub>2</sub></dict-term>
	  <dict-art>
	    <para>(Объединение.) Совпадает с последовательностью двух
	      строк, первая из который совпадает с
	      <term>regexp</term><sub>1</sub>, а вторая - с
	      <term>regexp</term><sub>2</sub>.</para>
	  </dict-art>
	  <dict-term><value>(</value><term>regexp</term><value>)</value></dict-term>
	  <dict-art>
	    <para>То же самое, что и <term>regexp</term>.</para>
	  </dict-art>
	  <dict-term><term>ident</term></dict-term>
	  <dict-art>
	    <para>Ссылка на регулярное выражение, связанное с
	      <term>ident</term> ранее определением <value>let</value>
	      <term>ident</term> <value>=</value>
	      <term>regexp</term>.</para>
	  </dict-art>
	</dict>
	<para>Что касается приоритета, то наивысший у * и +, затем
	  следует ?, затем объединение и, наконец, |
	  (альтернатива).</para>
      </subsection>
      <subsection name="Действия" neednumber="1">
	<para>Действием может быть любое выражение Caml. Оно
	  вычисляется в зависимости от контекста, когда идентификатор
	  <keyword>lexbuf</keyword> связывается с текущим буфером
	  лексического анализатора. Некоторые распространенные случаи
	  использования <keyword>lexbuf</keyword>, а также операции с
	  буферами анализатора, определенные в модуле стандартной
	  библиотеки <keyword>Lexing</keyword> приведены ниже.</para>
	<dict>
	  <dict-term><keyword>Lexing.lexeme lexbuf</keyword></dict-term>
	  <dict-art>
	    <para>Возвращает совпавшую строку.</para>
	  </dict-art>
	  <dict-term><keyword>Lexing.lexeme_char lexbuf</keyword> <emph>n</emph></dict-term>
	  <dict-art>
	    <para>Возвращает <emph>n</emph>-ный символ совпавшей
	      строки. Для первого символа <emph>n</emph> = 0.</para>
	  </dict-art>
	  <dict-term><keyword>Lexing.lexeme_start lexbuf</keyword></dict-term>
	  <dict-art>
	    <para>Вовзращает абсолютную позицию начала совпавшей строки во
	      входном тексте. Первый считанный символ входного текста
	      имеет позицию 0.</para>
	  </dict-art>
	  <dict-term><keyword>Lexing.lexeme_end lexbuf</keyword></dict-term>
	  <dict-art>
	    <para>Вовзращает абсолютную позицию конца совпавшей строки во
	      входном тексте. Первый считанный символ входного текста
	      имеет позицию 0.</para>
	  </dict-art>
	  <dict-term><emph>entrypoint</emph> <keyword>lexbuf</keyword></dict-term>
	  <dict-art>
	    <para>(Где <emph>entrypoint</emph> - имя другого вхождения в том же определении анализатора.) Рекурсивно вызывает анализатор на заданном вхождении, что бывает полезно, например, для вложенных комментариев.</para>
	  </dict-art>
	  </dict>
      </subsection>
    </section>
  </main-matters>
</chapter>
