<?xml version="1.0" encoding="windows-1251"?>
<!DOCTYPE chapter SYSTEM "./core.dtd">
<chapter name="Пакетная компиляция (ocamlc)" number="8">
  <abstract>
    <para>В этой главе описывается пакетный компилятор языка Objective
    Caml <command>ocamlc</command>, который компилирует файлы с
    исходными текстами на языке Caml в объектные файлы с байткодом и
    компонует их, создавая самостоятельные исполняемые файлы с
    байткодом. Затем такие файлы запускаются интерпретатором байткода
    <command>ocamlrun</command>.</para>
  </abstract>
  <main-matters>
    <section name="Обзор компилятора">
      <para>По интерфейсу командной строки <command>ocamlc</command>
      похож на большинство компиляторов C. Он принимает несколько
      типов аргументов:</para>
      <list>
	<item>
	  <para>Аргументы, заканчивающиеся на <command>.mli</command>
	  считаются исходными файлами для интерфейсов единиц
	  компиляции. В интерфейсах указываются имена, экспортируемые
	  единицами компиляции: там объявлены имена переменных и их
	  типы, определены типы данных, объявлены абстрактные типы
	  данных, и т.д. Из файла <command>X.mli</command> компилятор
	  <command>ocamlc</command> создаст файл
	  <command>X.cmi</command> со скомпилированным
	  интерфейсом</para>
	</item>
	<item>
	  <para>Аргументы, заканчивающиеся на <command>.ml</command>
	  считаются исходными файлами для реализаций единиц
	  компиляции. Реализации содержат определения для имен,
	  экспортируемых единицей, а также выражения, вычисляемые на
	  предмет их сторонних эффектов. Из файла
	  <command>X.ml</command> компилятор <command>ocamlc</command>
	  создает объект с байткодом в файле
	  <command>X.cmo</command>.</para> <para>Если существует
	  интерфейс <command>X.mli</command>, реализация
	  <command>X.ml</command> сверяется с соотвествующим
	  скомпилированным интерфейсом <command>X.cmi</command>,
	  который уже считается существующим. Если файла
	  <command>X.mli</command> не найдено, при компиляции
	  <command>X.ml</command> создается также компилированный
	  интерфейс <command>X.cmi</command>, экспортирующий все, что
	  определено в реализации <command>X.ml</command>.</para>
	</item>
	<item>
	  <para>Аргументы, заканчивающиеся на <command>.cmo</command>,
	  считаются скомпилированными объектами с байткодом. Они
	  компонуются c объектными файлами, полученными в
	  результате компиляции файлов <command>.ml</command> (если
	  такие есть) и стандартной библиотекой Objective Caml. В
	  результате создается самостоятельная исполняемая
	  программа. Порядок следования в командной строке аргументов
	  <command>.cmo</command> и <command>.ml</command> важен: во
	  время исполнения единицы компиляции инициализируются в том
	  же порядке, так что во время компоновки ошибкой будет
	  использовать компонент единицы до ее инициализации. Поэтому
	  файл <command>X.cmo</command> должен стоять в командной
	  строке компилятора прежде любых файлов
	  <command>.cmo</command>, ссылающихся на единицу
	  <command>X</command>.</para>
	</item>
	<item>
	  <para>Аргументы, заканчивающиеся на <command>.cma</command>,
	  считаются библиотеками библиотеками объектов с
	  байткодом. Библиотека содержит в одом файле набор файлов,
	  компилированных в байткод (файлов
	  <command>.cmo</command>). Она создается командой
	  <command>ocamlc -a</command> (описание опций приведено
	  ниже). Объетные файлы в библиотеке компонуются как обычные
	  файлы <command>.cmo</command> (см. выше) в том же порядке, в
	  каком строился файл <command>.cma</command>. Единственное
	  различие состоитв том, что, если в программе нет ссылок на
	  какой-то объектный файл в библиотеке, то он и не компонуется
	  с программой.</para>
	</item>
	<item>
	  <para>Аргументы, заканчивающиеся на <command>.c</command>,
	  передаются комплятору С, который генерирует объектный файл
	  <command>.o</command>. Затем этот файл компонуется с
	  программой, если был задан флаг <command>-custom</command>
	  (описание опций см. ниже).</para>
	</item>
	<item>
	  <para>Аргументы, заканчивающиеся на <command>.o</command>
	  или <command>.a</command> (<command>.obj</command> и
	  <command>.lib</command> под Windows) считаются объекнтыми
	  файлами и библиотеками С. Они передаются компоновщику С при
	  компоновке в режиме <command>-custom</command> (см. описание
	  опций ниже).</para>
	</item>
	<item>
	  <para>Аргументы, заканчивающиеся на <command>.so</command>
	  (<command>.dll</command> под Windows, считаются совместно
	  используемыми библиотеками С. Во время компоновки в них
	  ищутся внешние функции С, на которые есть ссылки в коде
	  Caml, и имена этих библиотек записываются в байткод
	  исполнямых файлов. Система времени исполнения
	  <command>ocamlrun</command> загружает необходимые библиотеки
	  динамически при запуске программы.</para>
	</item>
      </list>
      <para>На стадии компоновки генерируется файл, содержащий
      скомпилированный байткод, пригодный к исполнению интерпретатором
      байкода Objective Caml - программой
      <command>ocamlrun</command>. Для скомпилированного файла
      <command>caml.out</command> команда</para> 
      <listing><![CDATA[ocamlrun caml.out arg1 arg2 ... argn]]></listing>

         <para>выполнит скомпилированный код, содержащийся в файле
         <command>caml.out</command>, передав ему как аргументы
         символьные строки от <command>arg1</command> до
         <command>argn</command>. (Дополнительно см. главу 10.)</para>
         <para>В большинстве систем файл, созданный на стадии
         компоновки можно запускать непосредственно:</para>
         <listing><![CDATA[./caml.out arg1 arg2 ... argn]]></listing>
         <para>Бит исполнения обычно уже установлен, поэтому
         интерпретатор байткода запустится автоматически.</para>
    </section>
    <section name="Опции">
      <para><command>ocamlc</command> разпознает следующие опции
      командной строки:</para>
      <command-option-group>
	<command-option>
	  <c-option>
	    <mc-option>-a</mc-option>
	    <c-param></c-param>
	  </c-option>
	  <option-description>
	    <para>Создает библиотеку (файл <command>.cma</command>) из
	    объектных файлов <command>.cmo</command>, заданных в
	    командной строке. Имя библиотеки может быть задано с
	    помощью опции <command>-o</command>. Имя по умолчанию -
	    <command>library.cma</command></para>
	    
	    <para>Если в командной строке присутствуют опции
	    <command>-custom</command>, <command>-cclib</command> или
	    <command>-ccopt</command>, то они сохраняются в библиотеке
	    и затем автоматически добавляются при компоновке с этой
	    библиотекой к командной строке в исходном порядке, если
	    только не было задано опции
	    <command>-noautolink</command>.</para>
	    
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-c</mc-option>
	    <c-param></c-param>
	  </c-option>
	  <option-description>
	    <!-- one of (dict list listing para) --> <para>Только
	    компиляция. Фаза компоновки опускается. Файлы с исходным
	    текстом преобразуются в компилированные файлы, но
	    исполняемый файл не создается. Эта опция полезна для
	    раздельной компиляции модулей.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-cc</mc-option>
	    <c-param>ccomp</c-param>
	  </c-option>
	  <option-description>
	    <para>Использовать <command>ccomp</command> в качестве
	    компоновщика и компилятора С для компиляции файлов с
	    исходными текстами <command>.c</command> при вызове
	    <command>ocamlc -custom</command>.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-cclib</mc-option>
	    <c-param>-llibname</c-param>
	  </c-option>
	  <option-description>
	    <para>Передать компоновщику С опцию
	    <command>-llibname</command> при компиляции в "заказном"
	    режиме (см. описание опции <command>-custom</command>). В
	    результате данная библиотека С будет скомпонована с
	    программой.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-ccopt</mc-option>
	    <c-param>option</c-param>
	  </c-option>
	  <option-description>
	    <para>Передать данную опцию компилятору и компоновщику С
	    при сборке в "заказном" режиме (см. описание опции
	    <command>-custom</command>). Например, при задании
	    <command>-ccopt -Ldir</command> компоновщик С будет искать
	    библиотеки С в каталоге <command>dir</command>.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-custom</mc-option>
	    <c-param></c-param>
	  </c-option>
	  <option-description>
	    <para>Сборка в "заказном" режиме. В режиме по умолчанию
	    компоновщик создает байткод, предназначенный для
	    исполнения разделямой системой
	    <command>camlrun</command>. В заказном режиме
	    результирующий файл содержит как байткод, так и систему
	    времени выполнения. Он становится больше, но может
	    выполняться сам, даже если команда
	    <command>ocamlrun</command> не установлена. Кроме того,
	    заказной режим позволяет статически компоновать код Caml c
	    пользовательскими функциями на С, как описано в
	    гл. 18. Под Unix не используйте команду
	    <command>strip</command> для файлов, созданных
	    <command>ocamlc -custom</command>. Она удаляет байкод из
	    исполняемого файла.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-dllib</mc-option>
	    <c-param>-llibname</c-param>
	  </c-option>
	  <option-description>
	    <para>Разделяемая библиотека С
	    <command>libname.so</command>
	    (<command>libname.dll</command> под Windows) будет
	    загружена динамически системой времени исполнения
	    <command>ocamlrun</command> при старте программы.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-dllpath</mc-option>
	    <c-param>dir</c-param>
	  </c-option>
	  <option-description>
	    <para>Добавляет каталог <command>dir</command> к пути
	    поиска времени исполнения для разделяемых библиотек С. При
	    компоновке разделяемые библиотеки ищутся в стандартном
	    пути поиска (он соответсвует опции
	    <command>-I</command>). Опция <command>-dllpath</command>
	    просто сохраняет <command>dir</command> в исполняемом
	    файле, где <command>ocamlrun</command> может найти ее и
	    использовать, как описано в разделе 10.3.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-g</mc-option>
	    <c-param></c-param>
	  </c-option>
	  <option-description>
	    <para>Добавляет отладочную информацию во время компиляции
	    и компоновки. Эта опция необходима для того, чтобы
	    отлажиать программу с помощью
	    <command>ocamldebug</command> (см. гл. 16).</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-i</mc-option>
	    <c-param></c-param>
	  </c-option>
	  <option-description>
	    <para>Компилятор выводит все определенные имена (а также
	    автоматически распознанные типы или их определения) при
	    компиляции реализации (файл <command>.ml</command>. Это
	    бывает полезно для проверки типов, распознанных
	    компилятором. Кроме того, поскольку вывод соответствует
	    синтаксису интерфейсов, он может помочь явно написать
	    интерфейс (файл <command>.mli</command>) для файла:
	    достаточно перенаправить вывод компилятора в файл
	    <command>.mli</command> и убрать из результата декларации
	    имен, экспорт которых не предполагается.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-I</mc-option>
	    <c-param>directory</c-param>
	  </c-option>
	  <option-description>
	    <para>Добавляет <command>directory</command> к списку
	    каталогов, в которых ищутся компилированные файлы
	    интерфейсов (<command>.mli</command>), компилированные
	    объектные файлы (<command>.cml</command>), библиотеки
	    (<command>.cma</command>) и библиотеки С, заданнын в
	    опциях <command>-cclib -lxxx</command>. По умолчанию в
	    первую очередь файлы ищутся в текущем каталоге, затем - в
	    каталоге стандартной библиотеки. Каталоги, заданные опцией
	    <command>-I</command> учитываются после текущего, в том же
	    порядке, как они заданы в командной строке, но перед
	    стандартной библиотекой.</para> <para>Если каталог
	    начиначается со знака <command>+</command>, то он
	    считается заданным относительно каталога стандартной
	    библиотеки. Например, <command>-I +labltk</command>
	    добавляет к списку поиска подкаталог
	    <command>labltk</command> стандартной библиотеки.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-impl</mc-option>
	    <c-param>filename</c-param>
	  </c-option>
	  <option-description>
	    <para>Компилировать указанный файл как реализацию, даже
	    если его расширение отличается от
	    <command>.ml</command>.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-intf</mc-option>
	    <c-param>filename</c-param>
	  </c-option>
	  <option-description>
	    <para>Компилировать указанный файл как интерфейс, даже
	    если его расширение отличается от
	    <command>.mli</command>.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-linkall</mc-option>
	    <c-param></c-param>
	  </c-option>
	  <option-description>
	    <para>Принудительно компоновать все модули в
	    библиотеках. При отсутствии этой опции компонуются только
	    модули, на которые есть ссылки. При построении библиотеки
	    (флаг <command>-a</command>) установка флага
	    <command>-linkall</command> приводит к тому, что в
	    последующем при компиляции программ, использующих эту
	    библиотеку, все модули библиотеки будут компоноваться
	    заново.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-make-runtime</mc-option>
	    <c-param></c-param>
	  </c-option>
	  <option-description>
	    <para>Создает пользовательскую систему времени выполнения
	    (в файле, заданном опцией <command>-o</command>), внедряя
	    объектные файлы С и библитеки, указанные в командной
	    строке. Полученная система может быть использована позднее
	    для запуская исполняемого байткода, скомпилированного
	    командой <command>ocamlc -use-runtime
	    runtime-name</command>. Более подробная информация
	    содержится в разделе 18.1.6.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-noassert</mc-option>
	    <c-param></c-param>
	  </c-option>
	  <option-description>
	    <para>Отключает проверку утверждений, и утверждения не
	    компилируются. При компоновке ранее скомпилированных
	    файлов этот флаг не работает.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-noautolink</mc-option>
	    <c-param></c-param>
	  </c-option>
	  <option-description>
	    <para>При компоновке библиотек <command>.cma</command>
	    опции <command>-custom</command>,
	    <command>-cclib</command> и <command>-ccopt</command>,
	    вероятно хранящиеся в библиотеках (если они были указаны
	    при построении библиотек), игнорируются. Этот флаг
	    полезен, если библиотека содержит неправильные
	    спецификации библиотек или опций С. В этом случае надо
	    указать в командлной строке правильные библиотеки и опции
	    С.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-nolabels</mc-option>
	    <c-param></c-param>
	  </c-option>
	  <option-description>
	    <para>Игнорировать обязательные метки в типах. В этом
	    случае метки не могут использоваться в приложениях, и
	    порядок аргументов становится строгим.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-o</mc-option>
	    <c-param>exec-file</c-param>
	  </c-option>
	  <option-description>
	    <para>Имя файла, создаваемого компоновщиком. По умолчанию
	    по традициям Unix создается файл
	    <command>a.out</command>. Если используется опция
	    <command>-a</command>, укажите имя библиотеки. Если
	    используется опция <command>-output-obj</command>, укажите
	    имя объектного файла.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-output-obj</mc-option>
	    <c-param></c-param>
	  </c-option>
	  <option-description>
	    <para>Вместо исполняемого байткода компоновщик создает
	    объектный файл С. Это позволяет при необходимости оформить код
	    Caml как библиотеку С, которую можно вызывать из любой
	    программы С. Более подробно см. раздел 18.7.5. По
	    умолчанию создается файл <command>camlprog.o</command>, но
	    имя может быть задано с помощью опции
	    <command>-o</command>.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-pack</mc-option>
	    <c-param></c-param>
	  </c-option>
	  <option-description>
	    <para>Создает объектный файл с байткодом
	    (<command>.cmo</command>) и связанный с с ним
	    скомпилированный интерфейс (<command>.cmi</command>),
	    которые включают все объектные файлы, перечисленные в
	    командной строке. Эти файлы становятся субмодулями
	    результирующего файла <command>.cmo</command>. Имя
	    последнего задается опцией
	    <command>-o</command>. Например, </para>

	    <listing>ocamlc -pack -o p.cmo a.cmo b.cmo c.cmo</listing>

	    <para>создает компилированные файлы
	    <command>p.cmo</command> и <command>p.cmi</command>,
	    описывающие единицу компиляции, включающую субмодули A, B
	    и C, соотвествующие содержанию объектных файлов
	    <command>a.cmo</command>, <command>b.cmo</command> и
	    <command>c.cmo</command>. В дальнейшем на них можно
	    ссылаться как <command>P.A</command>,
	    <command>P.B</command> и <command>P.C</command>.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-pp</mc-option>
	    <c-param>command</c-param>
	  </c-option>
	  <option-description>
	    <para>Компилятр вызывает заданную команду
	    <command>command</command> как препроцессор для каждого
	    исходного файла. Вывод команды перенаправляется в
	    промежуточный файл, который и компилируется. Если
	    компиляция проходит без ошибок, по ее завершении
	    промежуточный файл удаляется. Имя файла конструируется на
	    основе имени исходного файла и получает расширение
	    <command>.ppi</command> для интерфейса
	    (<command>.mli</command>) или <command>.ppo</command> для
	    реализации (<command>.ml</command>).</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-principal</mc-option>
	    <c-param></c-param>
	  </c-option>
	  <option-description>
	    <para></para>
	  </option-description>
	</command-option>
      </command-option-group>
    </section>
  </main-matters>
</chapter>
