<?xml version="1.0" encoding="windows-1251"?>
<!DOCTYPE chapter SYSTEM "./core.dtd">
<chapter name="Пакетная компиляция (ocamlc)" number="8">
  <abstract>
    <para>В этой главе описывается пакетный компилятор языка Objective
    Caml <command>ocamlc</command>, который компилирует файлы с
    исходными текстами на языке Caml в объектные файлы с байткодом и
    компонует их, создавая самостоятельные исполняемые файлы с
    байткодом. Затем такие файлы запускаются интерпретатором байткода
    <command>ocamlrun</command>.</para>
  </abstract>
  <main-matters>
    <section name="Обзор компилятора">
      <para>По интерфейсу командной строки <command>ocamlc</command>
      похож на большинство компиляторов C. Он принимает несколько
      типов аргументов:</para>
      <list>
	<item>
	  <para>Аргументы, заканчивающиеся на <command>.mli</command>
	  считаются исходными файлами для интерфейсов единиц
	  компиляции. В интерфейсах указываются имена, экспортируемые
	  единицами компиляции: там объявлены имена переменных и их
	  типы, определены типы данных, объявлены абстрактные типы
	  данных, и т.д. Из файла <command>X.mli</command> компилятор
	  <command>ocamlc</command> создаст файл
	  <command>X.cmi</command> со скомпилированным
	  интерфейсом</para>
	</item>
	<item>
	  <para>Аргументы, заканчивающиеся на <command>.ml</command>
	  считаются исходными файлами для реализаций единиц
	  компиляции. Реализации содержат определения для имен,
	  экспортируемых единицей, а также выражения, вычисляемые на
	  предмет их сторонних эффектов. Из файла
	  <command>X.ml</command> компилятор <command>ocamlc</command>
	  создает объект с байткодом в файле
	  <command>X.cmo</command>.</para> <para>Если существует
	  интерфейс <command>X.mli</command>, реализация
	  <command>X.ml</command> сверяется с соотвествующим
	  скомпилированным интерфейсом <command>X.cmi</command>,
	  который уже считается существующим. Если файла
	  <command>X.mli</command> не найдено, при компиляции
	  <command>X.ml</command> создается также компилированный
	  интерфейс <command>X.cmi</command>, экспортирующий все, что
	  определено в реализации <command>X.ml</command>.</para>
	</item>
	<item>
	  <para>Аргументы, заканчивающиеся на <command>.cmo</command>,
	  считаются скомпилированными объектами с байткодом. Они
	  компонуются c объектными файлами, полученными в
	  результате компиляции файлов <command>.ml</command> (если
	  такие есть) и стандартной библиотекой Objective Caml. В
	  результате создается самостоятельная исполняемая
	  программа. Порядок следования в командной строке аргументов
	  <command>.cmo</command> и <command>.ml</command> важен: во
	  время исполнения единицы компиляции инициализируются в том
	  же порядке, так что во время компоновки ошибкой будет
	  использовать компонент единицы до ее инициализации. Поэтому
	  файл <command>X.cmo</command> должен стоять в командной
	  строке компилятора прежде любых файлов
	  <command>.cmo</command>, ссылающихся на единицу
	  <command>X</command>.</para>
	</item>
	<item>
	  <para>Аргументы, заканчивающиеся на <command>.cma</command>,
	  считаются библиотеками библиотеками объектов с
	  байткодом. Библиотека содержит в одом файле набор файлов,
	  компилированных в байткод (файлов
	  <command>.cmo</command>). Она создается командой
	  <command>ocamlc -a</command> (описание опций приведено
	  ниже). Объетные файлы в библиотеке компонуются как обычные
	  файлы <command>.cmo</command> (см. выше) в том же порядке, в
	  каком строился файл <command>.cma</command>. Единственное
	  различие состоитв том, что, если в программе нет ссылок на
	  какой-то объектный файл в библиотеке, то он и не компонуется
	  с программой.</para>
	</item>
	<item>
	  <para>Аргументы, заканчивающиеся на <command>.c</command>,
	  передаются комплятору С, который генерирует объектный файл
	  <command>.o</command>. Затем этот файл компонуется с
	  программой, если был задан флаг <command>-custom</command>
	  (описание опций см. ниже).</para>
	</item>
	<item>
	  <para>Аргументы, заканчивающиеся на <command>.o</command>
	  или <command>.a</command> (<command>.obj</command> и
	  <command>.lib</command> под Windows) считаются объекнтыми
	  файлами и библиотеками С. Они передаются компоновщику С при
	  компоновке в режиме <command>-custom</command> (см. описание
	  опций ниже).</para>
	</item>
	<item>
	  <para>Аргументы, заканчивающиеся на <command>.so</command>
	  (<command>.dll</command> под Windows, считаются совместно
	  используемыми библиотеками С. Во время компоновки в них
	  ищутся внешние функции С, на которые есть ссылки в коде
	  Caml, и имена этих библиотек записываются в байткод
	  исполнямых файлов. Система времени исполнения
	  <command>ocamlrun</command> загружает необходимые библиотеки
	  динамически при запуске программы.</para>
	</item>
      </list>
      <para>На стадии компоновки генерируется файл, содержащий
      скомпилированный байткод, пригодный к исполнению интерпретатором
      байкода Objective Caml - программой
      <command>ocamlrun</command>. Для скомпилированного файла
      <command>caml.out</command> команда</para> 
      <listing><![CDATA[ocamlrun caml.out arg1 arg2 ... argn]]></listing>

         <para>выполнит скомпилированный код, содержащийся в файле
         <command>caml.out</command>, передав ему как аргументы
         символьные строки от <command>arg1</command> до
         <command>argn</command>. (Дополнительно см. главу 10.)</para>
         <para>В большинстве систем файл, созданный на стадии
         компоновки можно запускать непосредственно:</para>
         <listing><![CDATA[./caml.out arg1 arg2 ... argn]]></listing>
         <para>Бит исполнения обычно уже установлен, поэтому
         интерпретатор байткода запустится автоматически.</para>
    </section>
    <section name="Опции">
      <para><command>ocamlc</command> разпознает следующие опции
      командной строки:</para>
      <command-option-group>
	<command-option>
	  <c-option>
	    <mc-option>-a</mc-option>
	    <c-param></c-param>
	  </c-option>
	  <option-description>
	    <para>Создает библиотеку (файл <command>.cma</command>) из
	    объектных файлов <command>.cmo</command>, заданных в
	    командной строке. Имя библиотеки может быть задано с
	    помощью опции <command>-o</command>. Имя по умолчанию -
	    <command>library.cma</command></para>
	    
	    <para>Если в командной строке присутствуют опции
	    <command>-custom</command>, <command>-cclib</command> или
	    <command>-ccopt</command>, то они сохраняются в библиотеке
	    и затем автоматически добавляются при компоновке с этой
	    библиотекой к командной строке в исходном порядке, если
	    только не было задано опции
	    <command>-noautolink</command>.</para>
	    
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-c</mc-option>
	    <c-param></c-param>
	  </c-option>
	  <option-description>
	    <!-- one of (dict list listing para) --> <para>Только
	    компиляция. Фаза компоновки опускается. Файлы с исходным
	    текстом преобразуются в компилированные файлы, но
	    исполняемый файл не создается. Эта опция полезна для
	    раздельной компиляции модулей.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-cc</mc-option>
	    <c-param>ccomp</c-param>
	  </c-option>
	  <option-description>
	    <para>Использовать <command>ccomp</command> в качестве
	    компоновщика и компилятора С для компиляции файлов с
	    исходными текстами <command>.c</command> при вызове
	    <command>ocamlc -custom</command>.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-cclib</mc-option>
	    <c-param>-llibname</c-param>
	  </c-option>
	  <option-description>
	    <para>Передать компоновщику С опцию
	    <command>-llibname</command> при компиляции в "заказном"
	    режиме (см. описание опции <command>-custom</command>). В
	    результате данная библиотека С будет скомпонована с
	    программой.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-ccopt</mc-option>
	    <c-param>option</c-param>
	  </c-option>
	  <option-description>
	    <para>Передать данную опцию компилятору и компоновщику С
	    при сборке в "заказном" режиме (см. описание опции
	    <command>-custom</command>). Например, при задании
	    <command>-ccopt -Ldir</command> компоновщик С будет искать
	    библиотеки С в каталоге <command>dir</command>.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-custom</mc-option>
	    <c-param></c-param>
	  </c-option>
	  <option-description>
	    <para>Сборка в "заказном" режиме. В режиме по умолчанию
	    компоновщик создает байткод, предназначенный для
	    исполнения разделямой системой
	    <command>camlrun</command>. В заказном режиме
	    результирующий файл содержит как байткод, так и систему
	    времени выполнения. Он становится больше, но может
	    выполняться сам, даже если команда
	    <command>ocamlrun</command> не установлена. Кроме того,
	    заказной режим позволяет статически компоновать код Caml c
	    пользовательскими функциями на С, как описано в
	    гл. 18. Под Unix не используйте команду
	    <command>strip</command> для файлов, созданных
	    <command>ocamlc -custom</command>. Она удаляет байкод из
	    исполняемого файла.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-dllib</mc-option>
	    <c-param>-llibname</c-param>
	  </c-option>
	  <option-description>
	    <para>Разделяемая библиотека С
	    <command>libname.so</command>
	    (<command>libname.dll</command> под Windows) будет
	    загружена динамически системой времени исполнения
	    <command>ocamlrun</command> при старте программы.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-dllpath</mc-option>
	    <c-param>dir</c-param>
	  </c-option>
	  <option-description>
	    <para>Добавляет каталог <command>dir</command> к пути
	    поиска времени исполнения для разделяемых библиотек С. При
	    компоновке разделяемые библиотеки ищутся в стандартном
	    пути поиска (он соответсвует опции
	    <command>-I</command>). Опция <command>-dllpath</command>
	    просто сохраняет <command>dir</command> в исполняемом
	    файле, где <command>ocamlrun</command> может найти ее и
	    использовать, как описано в разделе 10.3.</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-g</mc-option>
	    <c-param></c-param>
	  </c-option>
	  <option-description>
	    <para>Добавляет отладочную информацию во время компиляции
	    и компоновки. Эта опция необходима для того, чтобы
	    отлажиать программу с помощью
	    <command>ocamldebug</command> (см. гл. 16).</para>
	  </option-description>
	</command-option>
	<command-option>
	  <c-option>
	    <mc-option>-i</mc-option>
	    <c-param></c-param>
	  </c-option>
	  <option-description>
	    <para>Компилятор выводит все определенные имена (а также
	    автоматически распознанные типы или их определения) при
	    компиляции реализации (файл <command>.ml</command>. Это
	    бывает полезно для проверки типов, распознанных
	    компилятором. Кроме того, поскольку вывод соответствует
	    синтаксису интерфейсов, он может помочь явно написать
	    интерфейс (файл <command>.mli</command>) для файла:
	    достаточно перенаправить вывод компилятора в файл
	    <command>.mli</command> и убрать из результата декларации
	    имен, экспорт которых не предполагается.</para>
	  </option-description>
	</command-option>
      </command-option-group>
    </section>
  </main-matters>
</chapter>
