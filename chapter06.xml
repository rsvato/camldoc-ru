<?xml version="1.0" encoding="utf-8"?>
<!-- <!DOCTYPE chapter SYSTEM "core.dtd"> -->
<chapter name="Язык Objective Caml" number="6">
	<main-matters>
	<section name="Введение">
		<para>Эта глава является справочником по языку Objective Caml. Она перечисляет языковые конструкции и дает
		их точный синтаксис и неформальную семантику. Она никоим образом не может считаться учебником, и в ней нет ни
		одного примера кода. Ожидается, что читатель хорошо знает Caml.</para>
		<para>
			Нет здесь и математической точности. Слова употребляются в их обычном значении. Соотвественно, правила
			оформления также не соблюдаются в силу отсутсвия математеского аппарата, необходимого для их 
			формулировки. Тем не менее, они, разумеется, являются частью полного формального определения языка.
		</para>
		<subsection name="Нотация" neednumber="0">
			<para>
				Синтаксис языка приведен в нотации, напоминающей BNF. Терминальные символы обозначаются
				<value>таким образом</value>. Нетерминальные символы <term>оформлены так</term>. В квадратных
				скобках ([...]) перечислены необязательные элементы. Фигурные скобки ({...}) обозначают ноль и
				более повторяющихся компонентов. Если фигурные скобки сопровождаются знаком плюса ({...}<sub>+</sub>),
				то это означает, что компонент повторяется один и более раз. Круглые скобки ((...)) означают группировку.
			</para>
		</subsection>
	</section>
	<section name="Лексические соглашения">
		<subsection name="Пробельные символы" neednumber="0">
			<para>
				Пробельными символами считаются: пробел, символ новой строки, горизонтальная табуляция, перевод строки,
				возврат каретки, подача страницы. Они игнорируются, но используются для разделения идентификаторов, 
				литералов и ключевых слов, которые в противном случае считались бы одним идентификатором, литералом
				или ключевым словом.
			</para>
		</subsection>
		<subsection name="Комментарии" neednumber="0">
			<para>Комментарии начинаются начинаются знаками (* без пробела между ними и заканчиваются знаками *)
				без пробела между ними. Они считаются пробельными символами и не могут находится внутри строки или 
				символьного литерала. Вложенные комментарии обрабатываются правильно.
			</para>
		</subsection>
		<subsection name="Идентификаторы" neednumber="0">
			<bnf>
				<term>ident</term>
				<def>
					<group>
						<or multiline="0">
							<choice><term>letter</term></choice>
							<choice><value>...</value></choice>
						</or>
					</group>
					<repetitive>
						<or>
							<choice><term>letter</term></choice>
							<choice><value>0...9</value></choice>
							<choice><value>_</value></choice>
							<choice><value>&apos;</value></choice>
						</or>
					</repetitive>
				</def>
			</bnf>
			<bnf>
				<term>letter</term>
				<def>
					<or multiline="0"><choice><value>A...Z</value></choice><choice><value>a...z</value></choice></or>
				</def>
			</bnf>
			<para>Идентификаторы состоят из последовательности букв, цифр, _ (символов подчеркивания), &apos; (одинарных
			кавычек), начинающейся с буквы или символа подчеркивания. Буквы включают по крайней мере пятьдесят два
			символа из набора ASCII в верхнем и нижнем регистрах. Текущая реализация (за исключением платформы MacOS)
			допускает также симоволы с акцентами из ISO 9959-1 (или ISO Latin 1). Значимы все символы в идентификаторе, и
			в текущей реализации его длина не ограничивается.
			</para>
		</subsection>
		<subsection name="Целочисленные литералы" neednumber="0">
			<bnf>
				<term>integer-literal</term>
				<def>
					<or multiline="1">
						<choice>
							<optional><value>-</value></optional>
							<repetitive count="1"><value>0..9</value></repetitive>
						</choice>
						<choice>
							<optional><value>-</value></optional>
							<group>
								<or multiline="0"><choice><value>0x</value></choice><choice><value>0X</value></choice></or>
							</group>
								<repetitive count="1">
									<or multiline="0">
										<choice><value>0...9</value></choice>
										<choice><value>A...F</value></choice>
										<choice><value>a..f</value></choice>
									</or>
								</repetitive>
						</choice>
						<choice>
							<optional><value>-</value></optional>
							<group>
								<or multiline="0"><choice><value>0o</value></choice><choice><value>0O</value></choice></or>
							</group>
								<repetitive count="1">
										<value>0...7</value>
								</repetitive>
						</choice>
						<choice>
							<optional><value>-</value></optional>
							<group>
								<or multiline="0"><choice><value>0b</value></choice><choice><value>0B</value></choice></or>
							</group>
								<repetitive count="1">
										<value>0...1</value>
								</repetitive>
						</choice>
					</or>
				</def>
			</bnf>
			<para>Целочисленный литерал - это последовательность из одной или нескольких цифр, которой может
			предшествовать знак минус. По умолчанию целочисленные литералы считаются десятичными (основание 10).
			Основание изменяется следующими префиксами:</para>
			<table cols="2">
				<thead>
					<trow>
						<tcell><para>Префикс</para></tcell>
						<tcell><para>Основание</para></tcell>
					</trow>
				</thead>
				<tbody>
					<trow>
						<tcell><para><keyword>0x, 0X</keyword></para></tcell>
						<tcell><para>шестнадцатиричное (основание 16)</para></tcell>
					</trow>
					<trow>
						<tcell><para><keyword>0o, 0O</keyword></para></tcell>
						<tcell><para>восьмеричное (основание 8)</para></tcell>
					</trow>
					<trow>
						<tcell><para><keyword>0b, 0B</keyword></para></tcell>
						<tcell><para>двоичное (основание 2)</para></tcell>
					</trow>
				</tbody>
			</table>
			<para>
				(Первое <keyword>0</keyword> - цифра ноль, второе <keyword>o</keyword> для двоичных чисел - буква
				 &quot;O&quot;). Интерпретация целочисленных литералов, не попадающих в приемлемый диапазон
				 значений для целого числа, не определена.
			</para>
		</subsection>
		<subsection name="Литералы для чисел с плавающей точкой" neednumber="0">
			<bnf>
				<term>float-literal</term>
				<def>
					<optional><value>-</value></optional>
					<repetitive count="1"><value>0...9</value></repetitive>
					<optional>
						<value>.</value>
						<repetitive>
							<value>0...9</value>
						</repetitive>
					</optional>
					<optional>
						<group>
							<or multiline="0">
								<choice>
									<value>e</value>
								</choice>
								<choice>
									<value>E</value>
								</choice>
							</or>
						</group>
						<optional>
							<or>
								<choice><value>+</value></choice>
								<choice><value>-</value></choice>
							</or>
						</optional>
						<repetitive count="1">
							<value>0...9</value>
						</repetitive>
					</optional>
				</def>
			</bnf>
			<para>Литералы для чисел с плавающей точкой состоят из трех частей - целочисленной, десятичной
			и экспоненты. Целочисленная часть - это последовательность из одной или нескольких цифр
			с необязательным знаком плюс или минус. Десятичная - точка, за которой следуют ноль или более цифр.
			Экспонента - буква <keyword>e</keyword> или <keyword>E</keyword>, необязательный знак плюс или
			минус и одна или более цифр. Десятичная часть или экспонента могут быть опущены, однако лучше, чтобы
			присутствовала хоть одна из них, чтобы число отличалось от целочисленных литералов. Интерпретация литералов
			для чисел с плавающей точкой, не попадающих в приемлемый диапазон, не определена.</para>
		</subsection>
		<subsection name="Символьные литералы" neednumber="0">
			<bnf>
				<term>char-literal</term>
				<def>
					<or multiline="1">
						<choice><value>'</value><term>regular-char</term><value>'</value></choice>
						<choice><value>'</value><term>escape-sequence</term><value>'</value></choice>
					</or>
				</def>
			</bnf>
			<bnf>
				<term>escape-sequence</term>
				<def>
					<or multiline="1">
						<choice>
							<value>\</value>
							<group>
								<or multiline="0">
									<choice><value>\</value></choice>
									<choice><value>"</value></choice>
									<choice><value>'</value></choice>
									<choice><value>n</value></choice>
									<choice><value>t</value></choice>
									<choice><value>b</value></choice>
									<choice><value>r</value></choice>
								</or>
							</group>
						</choice>
						<choice>
							<value>\</value>
							<group><value>0...9</value></group>
							<group><value>0...9</value></group>
							<group><value>0...9</value></group>
						</choice>
					</or>
				</def>
			</bnf>
			<para>Символьные литералы ограничиваются одинарными кавычками (<keyword>&apos;</keyword>). Две
			одинарные кавычки могут ограничивать либо один символ, отличный от &apos; и \, либо одну из управляющих
			последовательностей ниже:</para>
			<table cols="2">
				<thead>
					<trow>
						<tcell><para>Последовательность</para></tcell>
						<tcell><para>Обозначаемый символ</para></tcell>
					</trow>
				</thead>
				<tbody>
					<trow>
						<tcell><para><keyword>\\</keyword></para></tcell>
						<tcell><para>Обратная косая черта (\)</para></tcell>
					</trow>
					<trow>
						<tcell><para><keyword>\&quot;</keyword></para></tcell>
						<tcell><para>Двойная кавычка (&quot;)</para></tcell>
					</trow>
					<trow>
						<tcell><para><keyword>\&apos;</keyword></para></tcell>
						<tcell><para>Одинарная кавычка (&apos;)</para></tcell>
					</trow>
					<trow>
						<tcell><para><keyword>\n</keyword></para></tcell>
						<tcell><para>Перевод строки (LF)</para></tcell>
					</trow>
					<trow>
						<tcell><para><keyword>\r</keyword></para></tcell>
						<tcell><para>Возврат каретки (CR)</para></tcell>
					</trow>
					<trow>
						<tcell><para><keyword>\t</keyword></para></tcell>
						<tcell><para>Горизонтальная табуляция (TAB)</para></tcell>
					</trow>
					<trow>
						<tcell><para><keyword>\b</keyword></para></tcell>
						<tcell><para>Забой (BS)</para></tcell>
					</trow>
					<trow>
						<tcell><para><keyword>\ddd</keyword></para></tcell>
						<tcell><para>Символ с десятичным кодом ASCII <keyword>ddd</keyword></para></tcell>
					</trow>
				</tbody>
			</table>
		</subsection>
		<subsection name="Строковые литералы" neednumber="0">
			<bnf>
				<term>string-literal</term>
				<def>
					<value>&quot;</value>
					<repetitive><term>string-character</term></repetitive>
					<value>&quot;</value>
				</def>
			</bnf>
			<bnf>
				<term>string-character</term>
				<def>
					<or multiline="1">
						<choice>
							<term>regular-char</term>
						</choice>
						<choice>
							<term>escape-sequence</term>
						</choice>
					</or>
				</def>
			</bnf>
			<para>
				Строковые литералы ограничиваются двойными кавычками (<keyword>&quot;</keyword>). 
				Двойные кавычки могут ограничивать либо один символ, отличный от &apos; и \, либо одну из управляющих
			последовательностей из таблицы выше.
			</para>
			<para>
				Чтобы длинные строковые литералы можно было разбивать на несколько строк,
				последовательность <term>\newline blanks</term> (обратная косая черта внутри строки,
				за которой следует произвольное число пробельных символов
				в начале следующей строки) игнорируется.
			</para>
			<para>В текущей реализации длина строковых литералов практически не ограничена</para>
		</subsection>
		<subsection name="Именованные метки" neednumber="0">
			<para>
				Во избежание двусмысленностей именованные метки нельзя просто определить синтаксически
				как последовательность трех токенов <value>~</value>, <term>ident</term> и <keyword>:</keyword>.
				Они требуют определения на лексическом уровне.
			</para>
			<bnf>
				<term>label</term>
				<def>
					<value>~</value>
					<group><value>a...z</value></group>
					<repetitive count="1">
						<or multiline="0">
							<choice><term>letter</term></choice>
							<choice><value>0...9</value></choice>
							<choice><value>_</value></choice>
							<choice><value>&apos;</value></choice>
						</or>
					</repetitive>
					<value>:</value>
				</def>
			</bnf>
			<bnf>
				<term>oplabel</term>
				<def>
					<value>?</value>
					<group><value>a...z</value></group>
					<repetitive count="1">
						<or multiline="0">
							<choice><term>letter</term></choice>
							<choice><value>0...9</value></choice>
							<choice><value>_</value></choice>
							<choice><value>&apos;</value></choice>
						</or>
					</repetitive>
					<value>:</value>
				</def>
			</bnf>
			<para>
				Именованные метки бывают двух видов: <term>label</term> для обычных аргументов
				и <term>optlabel</term> для необязательных. Они отличаются только первым символом
				- <keyword>~</keyword> или <keyword>?</keyword>.
			</para>
		</subsection>
		<subsection name="Префиксные и инфиксные символы" neednumber="0">
			<bnf>
				<term>infix-symbol</term>
				<def>
					<group>
						<or multiline="0">
							<choice><value>=</value></choice>
							<choice><value>&lt;</value></choice>
							<choice><value>&gt;</value></choice>
							<choice><value>@</value></choice>
							<choice><value>^</value></choice>
							<choice><value>|</value></choice>
							<choice><value>&amp;</value></choice>
							<choice><value>+</value></choice>
							<choice><value>-</value></choice>
							<choice><value>*</value></choice>
							<choice><value>/</value></choice>
							<choice><value>$</value></choice>
							<choice><value>%</value></choice>
						</or>
					</group>
					<repetitive><term>operator-char</term></repetitive>
				</def>
			</bnf>
			<bnf>
				<term>prefix-symbol</term>
				<def>
					<group>
						<or multiline="0">
							<choice><value>~</value></choice>
							<choice><value>!</value></choice>
							<choice><value>?</value></choice>
						</or>
					</group>
					<repetitive><term>operator-char</term></repetitive>
				</def>
			</bnf>
			<bnf>
				<term>operator-char</term>
				<def>
						<or multiline="0">
							<choice><value>!</value></choice>
							<choice><value>:</value></choice>
							<choice><value>.</value></choice>
							<choice><value>~</value></choice>
							<choice><value>=</value></choice>
							<choice><value>&lt;</value></choice>
							<choice><value>&gt;</value></choice>
							<choice><value>@</value></choice>
							<choice><value>^</value></choice>
							<choice><value>|</value></choice>
							<choice><value>&amp;</value></choice>
							<choice><value>+</value></choice>
							<choice><value>-</value></choice>
							<choice><value>*</value></choice>
							<choice><value>/</value></choice>
							<choice><value>$</value></choice>
							<choice><value>%</value></choice>
						</or>
				</def>
			</bnf>
			<para>
				Последовательности &quot;символов операторов&quot; типа
				<keyword>&lt;=&gt;</keyword> или <keyword>!!</keyword> читаются как 
				один токен из классов <term>infix-char</term> или <term>prefix-char</term>.
				Такие символы разбраются как префиксные или инфиксные операторы внутри
				выражения или же ведут себя как идентификаторы.
			</para>
		</subsection>
		<subsection name="Ключевые слова" neednumber="0">
			<para>Следующие идентификаторы считаются ключевыми словами и не могут использоваться
			в другом качестве:</para>
			<listing>
				<![CDATA[
      and         as          assert      asr         begin       class
      closed      constraint  do          done        downto      else
      end         exception   external    false       for         fun
      function    functor     if          in          include     inherit
      land        lazy        let         lor         lsl         lsr
      lxor        match       method      mod         module      mutable
      new         of          open        or          parser      private
      rec         sig         struct      then        to          true
      try         type        val         virtual     when        while
      with ]]></listing>
			<para>
				Следующие последовательности символов также считаются ключевыми словами:
			</para>
			<listing><![CDATA[    #     &     '     (     )     *     ,     ->    ?
    ??    .     ..    .(    .[    :     ::    :=    ;
    ;;    <-    =     [     [|    [<    {<    ]     |]
    >]    >}    _     `     {     |     }     ~]]></listing>
		</subsection>
		<subsection name="Неоднозначности" neednumber="0">
			<para>Лексические неоднозначности решаются по правилу "длиннейшего совпадения":
			если последовательность символов может быть разбита на два токена несколькими
			способами, используется тот способ, который дает наиболее длинный первый токен.
			</para>
		</subsection>
		<subsection name="Директивы номера строки" neednumber="0">
			<bnf>
				<term>linenum-directive</term>
				<def>
					<or multiline="1">
						<choice>
							<value>#</value>
							<repetitive count="1"><value>0...9</value></repetitive>
						</choice>
						<choice>
							<value>#</value>
							<repetitive count="1"><value>0...9</value></repetitive>
							<value>&quot;</value>
							<term>string-character</term>
							<value>&quot;</value>
						</choice>
					</or>
				</def>
			</bnf>
			<para>
				Препроцессоры, генерирующие исходный код на Caml, могут 
				помещать в свой вывод директивы номера строки, и тогда компилятор
				сможет добавлять к сообщениям об ошибках имена строк и имена файлов до
				предварительной обработки, а не после нее. Директива номера строки
				состит из <keyword>#</keyword> (знак диеза), за которым следует положительное
				целое число (номер строки) и, возможно, символьная строка (имя файла).
				Во время лексического анализа директивы номера строки считаются
				пробельными символами.
			</para>
		</subsection>
	</section>
	<section name="Типы данных">
		<para>В этом разделе описываются типы данных, обрабатываемых в
		Objective Caml.</para>
		<subsection name="Базовые типы" neednumber="1">
			<subsubsection name="Целые числа">
				<para>Целочисленными значениями считаются целые числа от <power pow="30">-2</power>
				до <power pow="30">2</power> - 1, то есть от -1073741824 до 1073741823. Реализация
				может поддерживать больший диапазон значений: в настоящее время
				на 64-разрядных платформах поддерживаются целые от <power pow="62">-2</power>
				до <power pow="62">2</power> - 1</para>
			</subsubsection>
			<subsubsection name="Числа с плавающей точкой">
				<para>Значениями с плавающей точкой считаются числа в одноименном представлении.
				Текущая реализация использует числа с плавающей точкой с двойной точностью согласно
				стандарту ISO 754 c мантиссой 53 бита и экспонентой от -1024 до 1024.
				</para> 
			</subsubsection>
			<subsubsection name="Символы">
				<para>Символы представлены как 8-битные целые числа от 0 до 255. Коды символов от 0 до
				127 интерпретируются по стандарту ASCII. Текущая реализация интерпретирует коды 
				символов от 127 до 255 по стандарту ISO 8859-1.</para>
			</subsubsection>
			<subsubsection name="Символьные строки">
				<para>Символьная строка - это конечная последовательность символов. Текущая реализация
				поддерживает строки, содержащие до <power pow="24">2</power> - 6 (то есть, 16777210)
				символов.</para>
			</subsubsection>
		</subsection>
		<subsection name="Кортежи" neednumber="1">
			<para>Кортежи значений записываются как <keyword>(<index ind="1">v</index>, ...,
			<index ind="n">v</index>)</keyword>, что соотвествует n-кортежу из 
			значений от <index ind="1">v</index> до <index ind="n">v</index>. Текущая
			реализация поддерживает кортежи из максимум <power pow="22">2</power> - 1 (то есть
			4194303) элементов.
			</para>
		</subsection>
		<subsection name="Записи" neednumber="1">
			<para>Записи являются кортежами именованных значений. Запись 
			<keyword>{<index ind="1">field</index>=<index ind="1">v</index>; ... ;
			<index ind="n">field</index>=<index ind="n">v</index>}</keyword>
			связывает значение <index ind="i">v</index> с полем записи <index ind="i">field</index>
			для i=1 ... n. Текущая
			реализация поддерживает записи из максимум <power pow="22">2</power> - 1 (то есть
			4194303) элементов.
			</para>
		</subsection>
		<subsection name="Массивы" neednumber="1">
			<para>Массивы - это конечные, переменного размера последовательности значений одного типа.
			Текущая	реализация поддерживает массивы из максимум <power pow="22">2</power> - 1 (то есть
			4194303) элементов.
			</para>
		</subsection>
		<subsection name="Вариантные значения" neednumber="1">
			<para>
				Вариантные значения являются либо константными конструкторами, либо парой из
				неконстантного конструктора и значения. Первый случай записывается как
				<keyword>cconstr</keyword>, второй - как <keyword>ncconstr(v)</keyword>, где
				<keyword>v</keyword> - аргумент для неконстантного конструктора
				<keyword>ncconstr</keyword>.
			</para>
			<para>
				Следующие константы считаются встроенными константными конструкторами:
			</para>
			<table cols="2">
				<thead>
					<trow>
						<tcell>
							<para>Константа</para>
						</tcell>
						<tcell>
							<para>Конструктор</para>
						</tcell>
					</trow>
				</thead>
				<tbody>
					<trow>
						<tcell>
							<para><keyword>false</keyword></para>
						</tcell>
						<tcell>
							<para>булево значение false</para>
						</tcell>
					</trow>
					<trow>
						<tcell>
							<para><keyword>true</keyword></para>
						</tcell>
						<tcell>
							<para>булево значение true</para>
						</tcell>
					</trow>
					<trow>
						<tcell>
							<para><keyword>()</keyword></para>
						</tcell>
						<tcell>
							<para>значение "unit"</para>
						</tcell>
					</trow>
					<trow>
						<tcell>
							<para><keyword>[]</keyword></para>
						</tcell>
						<tcell>
							<para>пустой список</para>
						</tcell>
					</trow>
				</tbody>
			</table>
			<para>Текущая реализация ограничивает число конструкторов для данного
			вариантного типа числом 249.</para>
		</subsection>
		<subsection name="Полиморфные варианты" neednumber="1">
			<para>Полиморфные варианты - это альтернативная форма вариантного типа. Они не 
			принадлежат явно к предопределенному вариантному типу и подчиняются особым правилам
			типизации. Они могут записываться либо как константы - <keyword>`tag-name</keyword>,
			либо, в случае не константы, как <keyword>`tag-name(n)</keyword>.</para>
		</subsection>
		<subsection name="Функции" neednumber="1">
			<para>Функции являются отображением значений на значения.</para>
		</subsection>
		<subsection name="Объекты" neednumber="1">
			<para>
				Объекты включают скрытое внутреннее состояние, выражаемое как переменные экземпляра,
				и набор методов, предназначенных для доступа к этом переменным и их изменения.
				Структура объекта описывается в порождающем его классе.
			</para>
		</subsection>
	</section>
	<section name="Имена">
		<para>
			Идентификаторы используются для именования некторых классов 
			языковых объектов и возмоджности обращения к этим объектам по
			имени. Это:
		</para>
		<list type="plain">
			<item><para>имена значений (синтаксический класс <term>value-name</term>)</para></item>
			<item>
				<para>конструкторы значений (для константных - класс 
				<term>cconstr-name</term>, для неконстантных - <term>ncconstr-name</term>)</para>
			</item>
			<item>
				<para>метки (<term>label-name</term>)</para>
			</item>
			<item><para>теги вариантов (<term>tag-name</term>)</para></item>
			<item><para>конструкторы типов (<term>typeconstr-name</term>)</para></item>
			<item><para>поля записей (<term>field-name</term>)</para></item>
			<item><para>имена классов (<term>class-name</term>)</para></item>
			<item><para>имена методов (<term>method-name</term>)</para></item>
			<item><para>имена переменных экземпляра (<term>inst-var-name</term>)</para></item>
			<item><para>имена модулей (<term>module-name</term>)</para></item>
			<item><para>имена типов модулей (<term>modtype-name</term>)</para></item>
		</list>
		<para>Эти девять пространств имен как по контексту, так и по регистру имени:
		первая буква идентификатора может быть строчной (ниже <term>lowercace-ident</term>)
		или заглавной (ниже <term>capitalized-ident</term>). Знак подчеркивания
		в данном случае считается строчной буквой.
		</para>
		<subsection name="Именование объектов" neednumber="0">
			<bnf>
				<term>value-name</term>
				<def>
					<or multiline="1">
						<choice><term>lowercase-ident</term></choice>
						<choice><group><term>operator-name</term></group></choice>
					</or>
				</def>
			</bnf>
			<bnf>
				<term>operator-name</term>
				<def>
					<or multiline="0">
						<choice><term>prefix-symbol</term></choice>
						<choice><term>infix-symbol</term></choice>
						<choice><value>*</value></choice>
						<choice><value>=</value></choice>
						<choice><value>or</value></choice>
						<choice><value>&amp;</value></choice>
						<choice><value>:=</value></choice>
					</or>
				</def>
			</bnf>
			<bnf>
				<term>cconstr-name</term>
				<def>
					<or multiline="1">
						<choice><term>capitalized-ident</term></choice>
						<choice><value>false</value></choice>
						<choice><value>true</value></choice>
						<choice><value>[ ]</value></choice>
						<choice><value>( )</value></choice>
					</or>
				</def>
			</bnf>
			<bnf>
				<term>ncconstr-name</term>
				<def>
					<or multiline="1">
						<choice><term>capitalized-ident</term></choice>
						<choice><value>::</value></choice>
					</or>
				</def>
			</bnf>
			<bnf>
				<term>label-name</term>
				<def><term>lowercase-ident</term></def>
			</bnf>
			<bnf>
				<term>tag-name</term>
				<def><term>capitalized-ident</term></def>
			</bnf>
			<bnf>
				<term>typeconstr-name</term>
				<def><term>lowercase-ident</term></def>
			</bnf>
			<bnf>
				<term>field-name</term>
				<def><term>lowercase-ident</term></def>
			</bnf>
			<bnf>
				<term>module-name</term>
				<def><term>capitalized-ident</term></def>
			</bnf>
			<bnf>
				<term>modtype-name</term>
				<def><term>ident</term></def>
			</bnf>
			<bnf>
				<term>class-name</term>
				<def><term>lowercase-ident</term></def>
			</bnf>
			<bnf>
				<term>inst-var-name</term>
				<def><term>lowercase-ident</term></def>
			</bnf>
			<bnf>
				<term>method-name</term>
				<def><term>lowercase-ident</term></def>
			</bnf>
			<para>
				Как видно, префиксные и инфиксные символы, а также некторые
				ключевые слова можно использовать как имена значений, если
				заключить их в кавычки. Такие ключевые слова как &apos;false&apos;
				и &apos;::&apos; являются также именами конструкторов. Правила
				относительно регистра имен подытожены в следующей таблице:
			</para>
			<table cols="2">
				<thead>
					<trow>
						<tcell><para>Пространство имен</para></tcell>
						<tcell><para>Первая буква</para></tcell>
					</trow>
				</thead>
				<tbody>
					<trow>
						<tcell><para>Значения</para></tcell>
						<tcell><para>строчная</para></tcell>
					</trow>
					<trow>
						<tcell><para>Конструкторы</para></tcell>
						<tcell><para>прописная</para></tcell>
					</trow>
					<trow>
						<tcell><para>Метки</para></tcell>
						<tcell><para>прописная</para></tcell>
					</trow>
					<trow>
						<tcell><para>Теги вариантов</para></tcell>
						<tcell><para>прописная</para></tcell>
					</trow>
					<trow>
						<tcell><para>Конструкторы типа</para></tcell>
						<tcell><para>строчная</para></tcell>
					</trow>
					<trow>
						<tcell><para>Поля записей</para></tcell>
						<tcell><para>строчная</para></tcell>
					</trow>
					<trow>
						<tcell><para>Классы</para></tcell>
						<tcell><para>строчная</para></tcell>
					</trow>
					<trow>
						<tcell><para>Методы</para></tcell>
						<tcell><para>строчная</para></tcell>
					</trow>
					<trow>
						<tcell><para>Модули</para></tcell>
						<tcell><para>прописная</para></tcell>
					</trow>
					<trow>
						<tcell><para>Типы модулей</para></tcell>
						<tcell><para>любая</para></tcell>
					</trow>
				</tbody>
			</table>
			<para>Относительно тегов вариантов: текущая реализация принимает их
			в дюбом регистре, однако ради переносимости и совместимости с 
			будущими версиями OCaml рекомендуется избегать использовать в качесте
			первого симовла их имен строчные буквы.</para>
		</subsection>
		<subsection name="Ссылки на именованные объекты" neednumber="0">
			<bnf>
				<term>value-path</term>
				<def>
					<or multiline="1">
						<choice><term>value-name</term></choice>
						<choice>
							<term>module-path</term><value>.</value><term>lowercase-ident</term>
						</choice>
					</or>
				</def>
			</bnf>
			<bnf>
				<term>cconstr</term>
				<def>
					<or multiline="1">
						<choice><term>cconstr-name</term></choice>
						<choice>
							<term>module-path</term><value>.</value><term>capitalized-ident</term>
						</choice>
					</or>
				</def>
			</bnf>
			<bnf>
				<term>ncconstr</term>
				<def>
					<or multiline="1">
						<choice><term>ncconstr-name</term></choice>
						<choice>
							<term>module-path</term><value>.</value><term>capitalized-ident</term>
						</choice>
					</or>
				</def>
			</bnf>
			<bnf>
				<term>typecontstr</term>
				<def>
					<or multiline="1">
						<choice><term>typeconstr-name</term></choice>
						<choice>
							<term>extended-module-path</term><value>.</value><term>lowercase-ident</term>
						</choice>
					</or>
				</def>
			</bnf>
			<bnf>
				<term>field</term>
				<def>
					<or multiline="1">
						<choice><term>field-name</term></choice>
						<choice>
							<term>module-path</term><value>.</value><term>lowercase-ident</term>
						</choice>
					</or>
				</def>
			</bnf>
			<bnf>
				<term>module-path</term>
				<def>
					<or multiline="1">
						<choice><term>module-name</term></choice>
						<choice>
							<term>module-path</term><value>.</value><term>capitalized-ident</term>
						</choice>
					</or>
				</def>
			</bnf>
			<bnf>
				<term>extended-module-path</term>
				<def>
					<or multiline="1">
						<choice><term>module-name</term></choice>
						<choice>
							<term>extended-module-path</term><value>.</value><term>capitalized-ident</term>
						</choice>
						<choice>
							<term>extended-module-path</term>
							<group><term>extended-module-path</term></group>
						</choice>
					</or>
				</def>
			</bnf>
			<bnf>
				<term>modtype-path</term>
				<def>
					<or multiline="1">
						<choice><term>modtype-name</term></choice>
						<choice>
							<term>extended-module-path</term><value>.</value><term>ident</term>
						</choice>
					</or>
				</def>
			</bnf>
			<bnf>
				<term>class-path</term>
				<def>
					<or multiline="1">
						<choice><term>class-name</term></choice>
						<choice>
							<term>module-path</term><value>.</value><term>lowercase-ident</term>
						</choice>
					</or>
				</def>
			</bnf>
			<para>На именованный объект можно ссылаться либо по имени
			(учитывая обычные статичные правила области видимости для имен), либо 
			через путь доступа вида <term>prefix</term><value>.</value><term>name</term>,
			где <term>prefix</term> означает модуль, а <term>name</term> - имя
			объекта, определенного в этом модуле. Первый компонент пути
			<term>prefix</term> записывается либо как простое имя модуля,
			либо путь доступа вида
			<term>name1</term><value>.</value><term>name2</term>... в случаях,
			когда определяющий модуль сам вложен в другие модули. При ссылке на
			конструкторы типа или типы модуля <term>prefix</term> также может
			содержать простые вызовы функтора (как в синтаксическом классе
			<term>extended-module-path</term>), если определяющий модуль
			сам является результатом вызова функтора.
			</para>
			<para>
				Имена меток, тегов, методов и переменных экземпляров такого уточнения
				не требуют: метки, теги и методы глобальны, а переменные экземпляра
				локальны в пределах класса.
			</para>
		</subsection>
		</section>
		<section name="Выражения типа">
			<bnf>
				<term>typexpr</term>
				<def>
					<or multiline="1">
						<choice><value>&apos;</value><term>ident</term></choice>
						<choice><value>_</value></choice>
						<choice>
							<value>(</value>
											<term>typexpr</term>
							<value>)</value>
						</choice>
						<choice>
							<optional>
								<optional><value>?</value></optional>
								<term>ident</term><value>:</value>
							</optional>
							<term>typexpr</term>
							<value>-&gt;</value>
							<term>typexpr</term>
						</choice>
						<choice>
							<term>typexpr</term>
							<repetitive count="1">
								<value>*</value>
								<term>typexpr</term>
							</repetitive>
						</choice>
						<choice><term>typeconstr</term></choice>
						<choice><term>typexpr</term> <term>typeconstr</term></choice>
						<choice>
							<value>(</value>
									<term>typexpr</term>
									<repetitive><value>,</value> <term>typexpr</term></repetitive>
							<value>)</value>
							<term>typeconstr</term>
						</choice>
						<choice>
							<term>typexpr</term>
							<value>as &apos;</value>
							<term>ident</term>
						</choice>
						<choice>
							<value>[</value>
							<term>variant-type</term>
							<value>]</value>
						</choice>
						<choice>
							<value>&lt;</value>
							<optional><value>..</value></optional>
							<value>&gt;</value>
						</choice>
						<choice>
							<value>&lt;</value>
							<term>method-type</term>
							<repetitive><value>; </value><term>method-type</term></repetitive>
							<optional><value>; ..</value></optional>
							<value>&gt;</value>
						</choice>
						<choice>
							<value>#</value>
							<term>class-path</term>
						</choice>
						<choice>
							<term>typexpr</term>
							<value>#</value>
							<term>class-path</term>
						</choice>
						<choice>
							<value>(</value>
									<term>typexpr</term>
									<repetitive><value>,</value> <term>typexpr</term></repetitive>
							<value>)</value>
							<value>#</value>
							<term>class-path</term>
						</choice>
					</or>
				</def>
			</bnf>
			<bnf>
				<term>poly-typexpr</term>
				<def>
					<or multiline="1">
						<choice><term>typexpr</term></choice>
						<choice>
							<repetitive count="1">
								<value>'</value>
								<term>ident</term>
							</repetitive>
							<value>.</value>
							<term>typexpr</term>
						</choice>
					</or>
				</def>
			</bnf>
			<bnf>
				<term>method-type</term>
				<def>
					<term>method-name</term>
					<value>:</value>
					<term>poly-typexpr</term>
				</def>
			</bnf>
			<para>
				В таблице ниже привены относительные приоритет и ассоциативность операторов
				и конструкций незакрытых типов. Операторы с высшим приоритетом помещены
				в таблицу первыми.
			</para>
			<table cols="2">
				<thead>
					<trow>
						<tcell><para>Оператор</para></tcell>
						<tcell><para>Ассоциативность</para></tcell>
					</trow>
				</thead>
				<tbody>
					<trow>
						<tcell><para>Вызов конструктора типа</para></tcell>
						<tcell><para>--</para></tcell>
					</trow>
					<trow>
						<tcell><para>*</para></tcell>
						<tcell><para>--</para></tcell>
					</trow>
					<trow>
						<tcell><para>-&gt;</para></tcell>
						<tcell><para>правая</para></tcell>
					</trow>
					<trow>
						<tcell><para>as</para></tcell>
						<tcell><para>--</para></tcell>
					</trow>
				</tbody>
			</table>
			<para>
				Выражения типа обозначают типы в определениях типов данных, а
				также в ограничениях типа в образцах и выражениях.
			</para>
			<subsection name="Переменные типа" neednumber="0">
				<para>
					Выражение типа <value>'</value><term>ident</term> означает
					переменную типа с именем <term>ident</term>. Выражение <value>_</value>
					означает анонимную переменную типа. В определениях типов данных
					переменные являются именами параметров этих типов. В ограничениях
					они соответствуют непредусмотренным типам, которые могут быть
					созданы любым типом, чтобы соответствовать ограничению. Область 
					действия именованной переменной как правило ограничивается типом,
					в котором она определена, а за его пределами она может быть только
					обобщенной. Анонимые переменные такого ограничения не имеют.
				</para>
			</subsection>
			<subsection name="Типы в скобках" neednumber="0">
				<para>Выражение <value>(</value><term>typexpr</term><value>)</value>
				означает то же самое, что и <term>typexpr</term>.</para>
			</subsection>
			<subsection name="Типы функций" neednumber="0">
	<para>Выражение типа <term>typexpr</term><sub>1</sub>
	  <value>-&gt;</value> <term>typexpr</term><sub>2</sub>
	  означает тип функций,отображающий аргументы типа
	  <term>typexpr</term><sub>1</sub>
	  на результаты типа <term>typexpr</term><sub>2</sub>.
	</para>
	<para><term>label typexpr</term><sub>1</sub><value>-&gt;</value>
	<term>typexpr</term><sub>2</sub> означает тот же тип функции, однако
	  аргумент помечается меткой <term>label</term>.</para>
	<para><value>?</value><term>label typexpr</term><sub>1</sub><value>-&gt;</value>
	<term>typexpr</term><sub>2</sub>  означает тип функций,отображающий
	необязательные аргументы с меткой типа <term>typexpr</term><sub>1</sub>
	  на результаты типа <term>typexpr</term><sub>2</sub>. Иными словами,
	  физический тип функции будет <term>typexpr</term><sub>1</sub>
	  <value>option -&gt;</value><term>typexpr</term><sub>2</sub>.
	</para>
			</subsection>
	</section>
	</main-matters>
</chapter>
